--- a/media/base/media_file_checker.cc
+++ b/media/base/media_file_checker.cc
@@ -66,14 +66,11 @@ bool MediaFileChecker::Start(base::TimeDelta check_time) {
     result = av_read_frame(glue.format_context(), &packet);
     if (result < 0)
       break;
-    result = av_dup_packet(&packet);
-    if (result < 0)
-      break;

     std::map<int, AVCodecContext*>::const_iterator it =
         stream_contexts.find(packet.stream_index);
     if (it == stream_contexts.end()) {
-      av_free_packet(&packet);
+      av_packet_unref(&packet);
       continue;
     }
     AVCodecContext* av_context = it->second;
@@ -81,7 +78,7 @@ bool MediaFileChecker::Start(base::TimeDelta check_time) {
     int frame_decoded = 0;
     if (av_context->codec_type == AVMEDIA_TYPE_AUDIO) {
       // A shallow copy of packet so we can slide packet.data as frames are
-      // decoded; otherwise av_free_packet() will corrupt memory.
+      // decoded; otherwise av_packet_unref() will corrupt memory.
       AVPacket temp_packet = packet;
       do {
         result = avcodec_decode_audio4(av_context, frame.get(), &frame_decoded,
@@ -99,7 +96,7 @@ bool MediaFileChecker::Start(base::TimeDelta check_time) {
       if (result >= 0 && frame_decoded)
         av_frame_unref(frame.get());
     }
-    av_free_packet(&packet);
+    av_packet_unref(&packet);
   } while (base::TimeTicks::Now() < deadline && read_ok && result >= 0);

   return read_ok && (result == AVERROR_EOF || result >= 0);
--- a/media/cast/test/fake_media_source.cc
+++ b/media/cast/test/fake_media_source.cc
@@ -441,7 +441,7 @@ void FakeMediaSource::DecodeAudio(ScopedAVPacket packet) {
   AVFrame* avframe = av_frame_alloc();

   // Make a shallow copy of packet so we can slide packet.data as frames are
-  // decoded from the packet; otherwise av_free_packet() will corrupt memory.
+  // decoded from the packet; otherwise av_packet_unref() will corrupt memory.
   AVPacket packet_temp = *packet.get();

   do {
--- a/media/ffmpeg/ffmpeg_common.h
+++ b/media/ffmpeg/ffmpeg_common.h
@@ -49,7 +49,7 @@ inline void ScopedPtrAVFree::operator()(void* x) const {

 inline void ScopedPtrAVFreePacket::operator()(void* x) const {
   AVPacket* packet = static_cast<AVPacket*>(x);
-  av_free_packet(packet);
+  av_packet_unref(packet);
   delete packet;
 }

--- a/media/filters/audio_decoder_unittest.cc
+++ b/media/filters/audio_decoder_unittest.cc
@@ -147,7 +147,7 @@ class AudioDecoderTest : public testing::TestWithParam<DecoderTestData> {
     EXPECT_EQ(GetParam().first_packet_pts, packet.pts);
     start_timestamp_ = ConvertFromTimeBase(
         reader_->GetAVStreamForTesting()->time_base, packet.pts);
-    av_free_packet(&packet);
+    av_packet_unref(&packet);

     // Seek back to the beginning.
     ASSERT_TRUE(reader_->SeekForTesting(start_timestamp_));
@@ -197,7 +197,7 @@ class AudioDecoderTest : public testing::TestWithParam<DecoderTestData> {
       SetDiscardPadding(&packet, buffer, GetParam().samples_per_second);

     // DecodeBuffer() shouldn't need the original packet since it uses the copy.
-    av_free_packet(&packet);
+    av_packet_unref(&packet);
     DecodeBuffer(buffer);
   }

--- a/media/filters/audio_file_reader.cc
+++ b/media/filters/audio_file_reader.cc
@@ -136,7 +136,7 @@ int AudioFileReader::Read(AudioBus* audio_bus) {
   while (current_frame < audio_bus->frames() && continue_decoding &&
          ReadPacket(&packet)) {
     // Make a shallow copy of packet so we can slide packet.data as frames are
-    // decoded from the packet; otherwise av_free_packet() will corrupt memory.
+    // decoded from the packet; otherwise av_packet_unref() will corrupt memory.
     AVPacket packet_temp = packet;
     do {
       // Reset frame to default values.
@@ -221,7 +221,7 @@ int AudioFileReader::Read(AudioBus* audio_bus) {

       current_frame += frames_read;
     } while (packet_temp.size > 0);
-    av_free_packet(&packet);
+    av_packet_unref(&packet);
   }

   // Zero any remaining frames.
@@ -257,11 +257,10 @@ bool AudioFileReader::ReadPacketForTesting(AVPacket* output_packet) {
 }

 bool AudioFileReader::ReadPacket(AVPacket* output_packet) {
-  while (av_read_frame(glue_->format_context(), output_packet) >= 0 &&
-         av_dup_packet(output_packet) >= 0) {
+  while (av_read_frame(glue_->format_context(), output_packet) >= 0) {
     // Skip packets from other streams.
     if (output_packet->stream_index != stream_index_) {
-      av_free_packet(output_packet);
+      av_packet_unref(output_packet);
       continue;
     }
     return true;
--- a/media/filters/audio_file_reader_unittest.cc
+++ b/media/filters/audio_file_reader_unittest.cc
@@ -73,7 +73,7 @@ class AudioFileReaderTest : public testing::Test {
           EXPECT_EQ(packet_md5_hashes_[j], md5_hash) << "j = " << j;
         }

-        av_free_packet(&packet);
+        av_packet_unref(&packet);
       }
       ASSERT_TRUE(reader_->SeekForTesting(start_timestamp));
     }
--- a/media/filters/ffmpeg_aac_bitstream_converter.cc
+++ b/media/filters/ffmpeg_aac_bitstream_converter.cc
@@ -230,7 +230,7 @@ bool FFmpegAACBitstreamConverter::ConvertPacket(AVPacket* packet) {
   av_packet_copy_props(&dest_packet, packet);

   // Release the old packet.
-  av_free_packet(packet);
+  av_packet_unref(packet);
   *packet = dest_packet;  // Finally, replace the values in the input packet.

   return true;
--- a/media/filters/ffmpeg_demuxer.cc
+++ b/media/filters/ffmpeg_demuxer.cc
@@ -861,7 +861,7 @@ void FFmpegDemuxer::Initialize(DemuxerHost* host,
   // this does not increase the amount of data downloaded.  The default value
   // is 5 AV_TIME_BASE units (1 second each), which prevents some oddly muxed
   // streams from being detected properly; this value was chosen arbitrarily.
-  format_context->max_analyze_duration2 = 60 * AV_TIME_BASE;
+  format_context->max_analyze_duration = 60 * AV_TIME_BASE;

   // Open the AVFormatContext using our glue layer.
   CHECK(blocking_thread_.Start());
--- a/media/filters/ffmpeg_h264_to_annex_b_bitstream_converter.cc
+++ b/media/filters/ffmpeg_h264_to_annex_b_bitstream_converter.cc
@@ -71,7 +71,7 @@ bool FFmpegH264ToAnnexBBitstreamConverter::ConvertPacket(AVPacket* packet) {
     configuration_processed_ = true;

   // At the end we must destroy the old packet.
-  av_free_packet(packet);
+  av_packet_unref(packet);
   *packet = dest_packet;  // Finally, replace the values in the input packet.

   return true;
--- a/media/filters/ffmpeg_h265_to_annex_b_bitstream_converter.cc
+++ b/media/filters/ffmpeg_h265_to_annex_b_bitstream_converter.cc
@@ -84,7 +84,7 @@ bool FFmpegH265ToAnnexBBitstreamConverter::ConvertPacket(AVPacket* packet) {
   memcpy(dest_packet.data, &input_frame[0], input_frame.size());

   // At the end we must destroy the old packet.
-  av_free_packet(packet);
+  av_packet_unref(packet);
   *packet = dest_packet;  // Finally, replace the values in the input packet.

   return true;
